class Cell {

  //  Objects
  DNA dna;         // DNA

  // BOOLEAN
  boolean fertile;

  // GROWTH AND REPRODUCTION
  float age;       // Age (nr. of frames since birth)
  float lifespan;
  float fertility; // Condition for becoming fertile
  int spawnCount;

  // SIZE AND SHAPE
  float cellStartSize;
  float cellEndSize;
  float r;         // Radius (half the width/height of the ellipse, which is drawn with width = r * 2)
  float flatness;  // To make flatter ellipses (1 = circle)
  float growth;    // Radius grows by this amount per frame
  float drawStep;  // To enable spacing of the drawn object (ellipse)
  float drawStepN;

  // MOVEMENT
  PVector position;
  PVector velocityLinear;
  PVector velocityNoise;
  float noisePercent;
  float spiral;
  float vMax;   // multiplication factor for velocity
  float xoff;       // x offset
  float yoff;       // y offset
  float step;       // step size

  // FILL COLOUR
  PVector fill_Colour;   // For HSB you need Hue to be the heading of a PVector
  PVector spawnCol;      // spawnCol needs to be a GLOBAL variable
  float fill_H;         // Hue (HSB) / Red (RGB)
  float fill_S;         // Saturation (HSB) / Green (RGB)
  float fill_B;         // Brightness (HSB) / Blue (RGB)
  float fill_Alpha;      // Transparency (HSB & RGB)

  // FILL COLOUR
  PVector stroke_Colour; // For HSB you need Hue to be the heading of a PVector
  float stroke_H;       // Hue (HSB) / Red (RGB)
  float stroke_S;       // Saturation (HSB) / Green (RGB)
  float stroke_B;       // Brightness (HSB) / Blue (RGB)
  float stroke_Alpha;    // Transparency (HSB & RGB)

  // CONSTRUCTOR: create a 'cell' object
  Cell (PVector pos, PVector vel, DNA dna_) {
  // OBJECTS
  dna = dna_;

  // DNA gene mapping (12 genes) NEW
  // 0 = fill Hue & vMax (Noise)
  // 1 = fill Saturation
  // 2 = fill Brightness & Spiral screw
  // 3 = fill Alpha
  // 4 = stroke Hue & step (Noise)
  // 5 = stroke Saturation
  // 6 = stroke Brightness & noisePercent
  // 7 = stroke Alpha
  // 8 = cellStartSize & Fertility (large size = lower fertility)
  // 9 = cellEndSize
  // 10 = lifespan & spawnCount (long lifespan = few children)
  // 11 = flatness & spiral handedness

  // BOOLEAN
  fertile = false; // A new cell always starts off infertile

  // GROWTH AND REPRODUCTION
  age = 0; // Age is 'number of frames since birth'. A new cell always starts with age = 0. From age comes maturity
  lifespan = map(dna.genes[10], 0, 1, 1000, 2000); // Lifespan can be lowered by DNA but not increased
  fertility = map(dna.genes[8], 1, 0, 0.7, 0.9); // How soon will the cell become fertile?
  spawnCount = int(map(dna.genes[10], 1, 0, 1, 5)); // Max. number of spawns

  // SIZE AND SHAPE
  cellStartSize = map(dna.genes[8], 0, 1, 10, 20);
  cellEndSize = cellStartSize * map(dna.genes[9], 0, 1, 0, 0.1);
  //r = cellStartSize; // Initial value for radius
  flatness = map(dna.genes[11], 0, 1, 0.5, 2); // To make circles into ellipses. range 0.5 - 1.5

  growth = (cellStartSize-cellEndSize)/lifespan; // Should work for both large>small and small>large
  drawStep = 1;
  drawStepB = 1;

  // MOVEMENT
  position = pos.copy(); //cell has position
  velocityLinear = vel.copy(); //cell has unique basic velocity component
  noisePercent = dna.genes[6]; // How much influence on velocity does Perlin noise have?
  spiral = map(dna.genes[2], 0, 1, -0.75, 0.75); // Spiral screw amount
  vMax = map(dna.genes[0], 0, 1, 0, 5); // Maximum magnitude in velocity components generated by noise
  xoff = random(1000); //Seed for noise
  yoff = random(1000); //Seed for noise
  step = map(dna.genes[3], 0, 1, 0.005, 0.005); //Step-size for noise

  // COLOUR

  fill_H = map(dna.genes[0], 0, 1, 0, 360);
  fill_S = map(dna.genes[1], 0, 1, 0, 255);
  fill_B = map(dna.genes[2], 0, 1, 0, 255);
  fillColor = color(fill_H, fill_S, fill_B); // Initial color is set
  fill_Alpha = map(dna.genes[3], 0, 1, 128, 255);

  stroke_HR = map(dna.genes[4], 0, 1, 0, 360);
  stroke_SG = map(dna.genes[5], 0, 1, 0, 255);
  stroke_BB = map(dna.genes[6], 0, 1, 0, 255);
  strokeColor = color(stroke_H, stroke_S, stroke_B); // Initial color is set
  stroke_Alpha = map(dna.genes[7], 0, 1, 0, 64);
  }

  void run() {
    live();
    updatePosition();
    updateSize();
    updateFertility();
    updateColour();
    if (p.wraparound) {checkBoundaryWraparound();}
    display();
    if (p.debug) {cellDebugger();}
  }

  void live() {
    age ++;
    maturity = map(age, 0, lifespan, 1, 0);
    drawStep --;
    drawStepStart = map(p.stepSize, 0, 100, 0 , (r *2 + growth));
    if (drawStep < 0) {drawStep = drawStepStart;}
    drawStepN--;
    drawStepNStart = map(p.stepSizeN, 0, 100, 0 , r *2);
    if (drawStepN < 0) {drawStepN = drawStepNStart;}
  }

  void updatePosition() { //Update parameters linked to the position
    float vx = map(noise(xoff),0,1,-vMax,vMax);
    float vy = map(noise(yoff),0,1,-vMax,vMax);
    velocityNoise = new PVector(vx,vy);
    xoff += step;
    yoff += step;
    velocity = PVector.lerp(velocityLinear, velocityNoise, noisePercent);
    float screwAngle = map(maturity, 0, 1, 0, spiral * TWO_PI);
    if (dna.genes[11] >= 0.5) {screwAngle *= -1}
    velocity.rotate(screwAngle);
    position.add(velocity);
  }

  void updateSize() {
    r = ((sin(map(maturity, 1, 0, 0, PI)))+0)*cellStartSize;
  }

  void updateFertility() {
    if (maturity <= fertility) {fertile = true; } else {fertile = false; }
    if (spawnCount == 0) {fertility = 0;} // Once spawnCount has counted down to zero, the cell will spawn no more
  }

  void updateColour() {
    if (p.fill_STwist > 0) {fill_S = map(maturity, 1, 0, (255-p.fill_STwist), 255); fillColor = color(fill_H, fill_S, fill_B);} // Modulate fill saturation by radius
    if (p.fill_BTwist > 0) {fill_B = map(maturity, 0, 1, (255-p.fill_BTwist), 255); fillColor = color(fill_H, fill_S, fill_B);} // Modulate fill brightness by radius
    if (p.fill_ATwist > 0) {fill_Alpha = map(maturity, 0, 1, (255-p.fill_ATwist), 255);} // Modulate fill Alpha by radius
    if (p.fill_HTwist > 0) { // Modulate fill hue by radius. Does not change original hue value but replaces it with a 'twisted' version
      float fill_Htwisted = map(maturity, 1, 0, fill_H, fill_H+p.fill_HTwist);
      if (fill_Htwisted > 360) {fill_Htwisted -= 360;}
      fillColor = color(fill_Htwisted, fill_S, fill_B); //fill colour is updated with new hue value
    }
    if (p.stroke_STwist > 0) {stroke_S = map(maturity, 1, 0, (255-p.stroke_STwist), 255); strokeColor = color(stroke_H, stroke_S, stroke_B);} // Modulate stroke saturation by radius
    if (p.stroke_BTwist > 0) {stroke_B = map(maturity, 0, 1, (255-p.stroke_BTwist), 255); strokeColor = color(stroke_H, stroke_S, stroke_B);} // Modulate stroke brightness by radius
    if (p.stroke_ATwist > 0) {stroke_Alpha = map(maturity, 0, 1, (255-p.stroke_ATwist), 255);} // Modulate stroke Alpha by radius
    if (p.stroke_HTwist > 0) { // Modulate stroke hue by radius
      float stroke_Htwisted = map(maturity, 1, 0, stroke_H, stroke_H+p.stroke_HTwist);
      if (stroke_Htwisted > 360) {stroke_Htwisted -= 360;}
      strokeColor = color(stroke_Htwisted, stroke_S, stroke_B); //stroke colour is updated with new hue value
    }
  }
  
  void checkBoundaryRebound() {
    if (position.x > width-r) {
      position.x = width-r;
      velocity.x *= -1;
    }
    else if (position.x < r) {
      position.x = r;
      velocity.x *= -1;
    }
    else if (position.y > height-r) {
      position.y = height-r;
      velocity.y *= -1;
    }
    else if (position.y < r) {
      position.y = r;
      velocity.y *= -1;
    }
  }

  void checkBoundaryWraparound() {
    if (position.x > width+r) {
      position.x = -r;
    }
    else if (position.x < -r) {
      position.x = width+r;
    }
    else if (position.y > height+r) {
      position.y = -r;
    }
    else if (position.y < -r) {
      position.y = height+r;
    }
  }

 //<>//
  // Death
  boolean dead() {
    //if (velocity.mag() == 0) {return true; } // Death if stationary
    //if (collCount <= 0) {return true; } // Death if collision limit reached
    if (r < rMin) {return true; } // Death if size lower limit reached
    //if (health <0) {return true; } // Death if no health left
    if (position.x > width+r ||  position.x < -r || position.y > height+r ||  position.y < -r) { return true;  } // Death if move beyond canvas boundary
    else { return false; }
    //return false; // Use if no death
  }


  // Copied from the original Evolution EcoSystem sketch
  // NOT IN USE
  // Called from 'run' in colony to determine if a cell will spontaneously (& asexually) reproduce
  // Note: instead of void, the method returns a 'Cell' object
  Cell reproduce() {
    if (random(1) < 0.003) {
      DNA childDNA = dna.copy();    // Child DNA is exact copy of single parent
      // childDNA.geneMutate(0.01); // DNA can mutate if a random number is less than 0.01
      return new Cell (position, velocity, fill_Colour, childDNA, rStart); // this is a pretty cool trick!
    }
    else {
      return null; // If no child was spawned
    }
  }

  void colourTwist() { // To calculate fill colour H (in HSB) from PVector 'fill_Colour' heading. Assumes fill_HR is started from fill_colour PVector
    float twistAngle = map(r, rMin, rStart, -PI/12, PI/12);  // (rMax*PI/rMaxMax*4)
    PVector fillTemp = fill_Colour.copy();
    fillTemp.rotate(twistAngle); // Temporary vector to avoid the need to rotate back again
    spawnCol = fillTemp.copy();  // Set the spawnCol at the 'twisted' fillColour now (needed because colour is passed on as a vector, not fill_HR)
    fill_HR = map(fillTemp.heading(), -PI, PI, 0, 360);
    flatness = map(twistAngle, -PI/12, PI/12, 1, 1); // NOTE: This should probably be a seperate function 'shapetwist'

    fillTemp.rotate(strokeOffset); // stroke_HR has opposite heading to fill_HR. Angle offset could be mapped from something...
    //stroke_HR = map(fillTemp.heading(), -PI, PI, 0, 360);
  }

  void display() {
    if (greyscale) {
      stroke(stroke_HR); //stroke = Greyscale, 100% Alpha
      //stroke(stroke_HR, stroke_Alpha); // stroke = Greyscale
      //stroke(fill_HR, stroke_Alpha);   // stroke = Greyscale (use fill colour)
      fill(fill_HR, fill_Alpha); // fill = Greyscale
    }
    else {
      stroke(stroke_HR, stroke_SG, stroke_BB, stroke_Alpha); // stroke = Colour
      //stroke(fill_HR, stroke_SG, stroke_BB, stroke_Alpha);   // stroke = Colour (use fill colour)
      fill(fill_HR, fill_SG, fill_BB, fill_Alpha); // fill = Colour
    }
    //if (!fertile) {noStroke();}
    //noFill();

    if (stepped) { // Will only draw ellipse when toggle is true, giving a stepped effect. See develop();
      if (toggle) {
      float angle = velocity.heading();
      pushMatrix();
      translate(position.x,position.y);
      rotate(angle);
      ellipse(0, 0, r, r*flatness);
      popMatrix();
      toggle = false;
      }
    }
    else {
      float angle = velocity.heading();
      pushMatrix();
      translate(position.x,position.y);
      rotate(angle);
      ellipse(0, 0, r, r*flatness);
      if (fertile) {fill(0); ellipse(0, 0, rMin, rMin);} else {fill(255); ellipse(0, 0, rMin, rMin);}
      //if (fertile) {fill(255); ellipse(0, 0, rMin, rMin);} else {fill(255, seed_Alpha); ellipse(0, 0, rMin, rMin);}
      //if (fertile) {fill(255); noStroke(); ellipse(0, 0, rMin, rMin);} else {stroke(255); noFill(); ellipse(0, 0, rMin, rMin);}
      popMatrix();
    }
  }

  void checkCollision(Cell other) {       // Method receives a Cell object 'other' to get the required info about the collidee
    if (fertile) {                        // Collision is only checked on fertile cells.
                                          // This is a hack to prevent young spawn from colliding with their parents. Is already prevented in Colony by age-limit (20)
      PVector distVect = PVector.sub(other.position, position); // Static vector to get distance between the cell & other

      // calculate magnitude of the vector separating the balls
      float distMag = distVect.mag();

      if (distMag < (r + other.r)) { // Test to see if a collision has occurred : is distance < sum of cell radius + other cell radius?

        //growth *= -1;         // Trying an idea - collision causes growthrate to toggle, even for infertile cells. See below.
        //other.growth *= -1;

        //grow = false;         // Trying an idea - stop growing on collision
        //other.grow = false;
        //move = false;         // Trying an idea - stop moving on collision
        //other.move = false;

        if (fertile && other.fertile) { // Test to see if both cell & other are fertile

         //growth *= -1;         // Collision resulting in spawn causes growth-rate to toggle.
         //other.growth *= -1;

         // Update radius's    // Trying an idea - collision causes radius to shrink
         //r *= 0.1;
         //other.r *= 0.1;

         // Decrease collision counters. NOTE Only done on spawn, so is more like a 'spawn limit'
         collCount --;
         other.collCount --;

         // Calculate position for spawn based on PVector between cell & other (leaving 'distVect' unchanged, as it is needed later)
         PVector spawnPos = distVect.copy();  // Create spawnPos as a copy of the (already available) distVect which points from parent cell to other
         spawnPos.normalize();
         spawnPos.mult(r);               // The spawn position is located at parent cell's radius
         spawnPos.add(position);

         // Calculate velocity vector for spawn as being centered between parent cell & other
         PVector spawnVel = velocity.copy(); // Create spawnVel as a copy of parent cell's velocity vector
         spawnVel.add(other.velocity);       // Add dad's velocity
         spawnVel.normalize();               // Normalize to leave just the direction and magnitude of 1 (will be multiplied later)

         // Calculate colour vector for spawn
         PVector spawnCol = fill_Colour.copy(); // Create spawnCol by copying the current cell's colour vector
         spawnCol.add(other.fill_Colour);       // Add the other cell's colour vector (for heading)
         spawnCol.normalize();          // Normalize to magnitude = 1
         float spawnMag = (fill_Colour.mag() + other.fill_Colour.mag())/2; // New magnitude is average of mum & dad. Could this be the culprit? //<>// //<>//
         spawnCol.mult(spawnMag);       // Give spawnCol the averaged magnitude

         // Calculate rStart for child;
         rStart = r; // Spawn starts with same radius as current r (& resets fertility at the same time)
         other.rStart = other.r; // Resets fertility for other too

         // Call spawn method (in Colony) with the new parameters for position, velocity and fill-colour etc.)
         colony.spawn(position.x, position.y, spawnVel.x, spawnVel.y, spawnCol.heading(), spawnCol.mag(), rStart);

         // Reset fertility counter (from before fertile became boolean)
         //fertility = 0;
         //other.fertility = 0;
        }

      // get angle of distVect
      float theta  = distVect.heading();
      // precalculate trig values
      float sine = sin(theta);
      float cosine = cos(theta);

      // posTemp will hold rotated cell positions. You just need to worry about posTemp[1] position
      PVector[] posTemp = { new PVector(), new PVector() };

      /* this ball's position is relative to the other so you can use the vector between them (distVect) as the reference point in the rotation expressions.
      posTemp[0].position.x and posTemp[0].position.y will initialize automatically to 0.0, which is what you want since b[1] will rotate around b[0] */
      posTemp[1].x  = cosine * distVect.x + sine * distVect.y;
      posTemp[1].y  = cosine * distVect.y - sine * distVect.x;

      // rotate Temporary velocities
      PVector[] vTemp = { new PVector(), new PVector() };

      vTemp[0].x  = cosine * velocity.x + sine * velocity.y;
      vTemp[0].y  = cosine * velocity.y - sine * velocity.x;
      vTemp[1].x  = cosine * other.velocity.x + sine * other.velocity.y;
      vTemp[1].y  = cosine * other.velocity.y - sine * other.velocity.x;

      // Now that velocities are rotated, you can use 1D conservation of momentum equations to calculate  the final velocity along the x-axis.
      PVector[] vFinal = { new PVector(), new PVector() };

      // final rotated velocity for b[0]
      vFinal[0].x = ((m - other.m) * vTemp[0].x + 2 * other.m * vTemp[1].x) / (m + other.m);
      vFinal[0].y = vTemp[0].y;

      // final rotated velocity for b[0]
      vFinal[1].x = ((other.m - m) * vTemp[1].x + 2 * m * vTemp[0].x) / (m + other.m);
      vFinal[1].y = vTemp[1].y;

      // hack to avoid clumping (???????? How does it work, actually?)
      posTemp[0].x += vFinal[0].x;
      posTemp[1].x += vFinal[1].x;

      // Rotate ball positions and velocities back. Reverse signs in trig expressions to rotate in the opposite direction
      PVector[] posFinal = { new PVector(), new PVector() };

      posFinal[0].x = cosine * posTemp[0].x - sine * posTemp[0].y;
      posFinal[0].y = cosine * posTemp[0].y + sine * posTemp[0].x;
      posFinal[1].x = cosine * posTemp[1].x - sine * posTemp[1].y;
      posFinal[1].y = cosine * posTemp[1].y + sine * posTemp[1].x;

      // update balls to screen position
      other.position.x = position.x + posFinal[1].x;
      other.position.y = position.y + posFinal[1].y;

      position.add(posFinal[0]);

      // update velocities
      velocity.x = cosine * vFinal[0].x - sine * vFinal[0].y;
      velocity.y = cosine * vFinal[0].y + sine * vFinal[0].x;
      other.velocity.x = cosine * vFinal[1].x - sine * vFinal[1].y;
      other.velocity.y = cosine * vFinal[1].y + sine * vFinal[1].x;
      }
    }
  }

  void debugTextCell() { // For debug only
     //stroke(255);
     fill(0);
     //textSize(12);
     //text("Cells alive:" + colony.cells.size(), 0, 10);
     textSize(15);
     text("r:" + r, position.x, position.y);
     text("rStart:" + rStart, position.x, position.y+10);
     //text("fill_HR:" + fill_HR, position.x, position.y);

     //text("rMax:" + rMax, position.x, position.y+30);
     //text("growth:" + growth, position.x, position.y+30);
     //text("age:" + age, position.x, position.y+20);
     text("fertile:" + fertile, position.x, position.y+30);
     text("fertility:" + fertility, position.x, position.y+40);
     text("collCount:" + collCount, position.x, position.y+50);
     //text("x-velocity:" + velocity.x, position.x, position.y+0);
     //text("y-velocity:" + velocity.y, position.x, position.y+10);
     //text("velocity heading:" + velocity.heading(), position.x, position.y+20);
     //println("X: " + position.x + "   Y:" + position.y + "   r:" + r + "   m:" + m + "  collCount:" + collCount);
     //println("X: " + position.x + "   Width+r:" + (width+r) + "   Y:" + position.y  + "   height+r:" +(height+r) + "  r:" + r);
     }



}
